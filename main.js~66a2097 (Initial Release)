"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const adapter_core_1 = require("@iobroker/adapter-core");
const brain_discovery_1 = require("./lib/brain-discovery");
const config_1 = require("./lib/config");
const axios_1 = __importDefault(require("axios"));
class NeeoAdapter extends adapter_core_1.Adapter {
    constructor(options = {}) {
        super({ ...options, name: "neeo" });
        this.brainIp = "";
        this.brainPort = 0;
        this.pollInterval = config_1.POLL_INTERVAL;
        this.pollHandle = null;
        this.on("ready", this.onReady.bind(this));
        this.on("unload", this.onUnload.bind(this));
        this.on("stateChange", this.onStateChange.bind(this));
    }
    // Capitalize Names
    capitalize(text) {
        return text.charAt(0).toUpperCase() + text.slice(1);
    }
    // Start adapter
    async onReady() {
        this.log.info("Adapter started, connecting to NEEO Brain...");
        // Subscribe to state
        this.subscribeStates("*");
        // Fetch Brain data
        const model = await (0, brain_discovery_1.fetchNeeoBrainModel)(this);
        if (!model) {
            this.log.error("Could not fetch NEEO Brain data. Check IP/Port in adapter settings.");
            return;
        }
        this.brainIp = model.brainIp ?? '';
        this.brainPort = model.brainPort ?? 0;
        this.pollInterval = this.config.pollInterval ?? config_1.POLL_INTERVAL;
        this.log.info(`Brain model loaded: ${model.rooms.length} rooms, ${model.devices.length} devices, ${model.recipes.length} recipes, ${model.scenarios.length} scenarios`);
        // Delete old objects
        await this.clearAllObjects();
        // Create Info folder
        await this.setObjectNotExistsAsync(config_1.INFO, {
            type: "folder",
            common: { name: "Adapter Info" },
            native: {}
        });
        // Create object brainIp
        await this.setObjectNotExistsAsync(`${config_1.INFO}.brainIp`, {
            type: "state",
            common: {
                name: "Brain IP Address",
                type: "string",
                role: "info.ip",
                read: true,
                write: false
            },
            native: {}
        });
        await this.setState(`${config_1.INFO}.brainIp`, this.brainIp, true);
        // Create object brainPort
        await this.setObjectNotExistsAsync(`${config_1.INFO}.brainPort`, {
            type: "state",
            common: {
                name: "Brain Port",
                type: "number",
                role: "info.port",
                read: true,
                write: false
            },
            native: {}
        });
        await this.setState(`${config_1.INFO}.brainPort`, this.brainPort, true);
        // Create object pollInterval
        await this.setObjectNotExistsAsync(`${config_1.INFO}.pollInterval`, {
            type: "state",
            common: {
                name: "Polling Interval (s)",
                type: "number",
                unit: "s",
                role: "value.interval",
                read: true,
                write: false
            },
            native: {}
        });
        await this.setState(`${config_1.INFO}.pollInterval`, this.pollInterval, true);
        // Create object connection
        await this.setObjectNotExistsAsync(`${config_1.INFO}.connection`, {
            type: "state",
            common: {
                name: "Brain Online",
                type: "boolean",
                role: "indicator.reachable",
                read: true,
                write: false
            },
            native: {}
        });
        await this.setState(`${config_1.INFO}.connection`, false, true);
        // Create rooms
        for (const room of model.rooms) {
            const roomId = `${config_1.ROOMS}.${room.id}`;
            await this.setObjectNotExistsAsync(roomId, {
                type: "channel",
                common: { name: room.name },
                native: room
            });
            if (config_1.DEBUG_ENABLED)
                this.log.debug(`Created room object: ${roomId}`);
            // Create device, recipe, scenario folders
            await this.setObjectNotExistsAsync(`${roomId}.${config_1.DEVICES}`, {
                type: "folder",
                common: { name: this.capitalize(config_1.DEVICES) },
                native: {}
            });
            await this.setObjectNotExistsAsync(`${roomId}.${config_1.RECIPES}`, {
                type: "folder",
                common: { name: this.capitalize(config_1.RECIPES) },
                native: {}
            });
            await this.setObjectNotExistsAsync(`${roomId}.${config_1.SCENARIOS}`, {
                type: "folder",
                common: { name: this.capitalize(config_1.SCENARIOS) },
                native: {}
            });
        }
        // Create devices
        for (const device of model.devices) {
            const roomPath = `${config_1.ROOMS}.${device.roomId}`;
            const devId = `${roomPath}.${config_1.DEVICES}.${device.id}`;
            await this.setObjectNotExistsAsync(devId, {
                type: "channel",
                common: { name: device.name },
                native: device
            });
            if (config_1.DEBUG_ENABLED)
                this.log.debug(`Created device object: ${devId}`);
            const details = device.details || {};
            await this.setObjectNotExistsAsync(`${devId}.manufacturer`, {
                type: "state",
                common: {
                    name: "Manufacturer",
                    type: "string",
                    role: "info",
                    read: true,
                    write: false
                },
                native: {}
            });
            await this.setState(`${devId}.manufacturer`, details.manufacturer ?? "", true);
            await this.setObjectNotExistsAsync(`${devId}.modelName`, {
                type: "state",
                common: {
                    name: "Model Name",
                    type: "string",
                    role: "info",
                    read: true,
                    write: false
                },
                native: {}
            });
            await this.setState(`${devId}.modelName`, details.name ?? "", true);
            await this.setObjectNotExistsAsync(`${devId}.deviceType`, {
                type: "state",
                common: {
                    name: "Device Type",
                    type: "string",
                    role: "info",
                    read: true,
                    write: false
                },
                native: {}
            });
            await this.setState(`${devId}.deviceType`, details.type ?? "", true);
            // Create macros and commands folder
            await this.setObjectNotExistsAsync(`${devId}.${config_1.MACROS}`, {
                type: "folder",
                common: { name: this.capitalize(config_1.MACROS) },
                native: {}
            });
            await this.setObjectNotExistsAsync(`${devId}.${config_1.COMMANDS}`, {
                type: "folder",
                common: { name: this.capitalize(config_1.COMMANDS) },
                native: {}
            });
            // Create macros
            const macros = device.macros ?? [];
            for (const macro of macros) {
                const macroId = `${devId}.${config_1.MACROS}.${macro.id}`;
                await this.setObjectNotExistsAsync(macroId, {
                    type: "state",
                    common: {
                        name: macro.label || macro.name,
                        type: "boolean",
                        role: "button",
                        read: false,
                        write: true
                    },
                    native: {
                        macroKey: macro.id,
                        deviceKey: device.id,
                        roomKey: device.roomId
                    }
                });
                await this.setState(macroId, false, true);
                if (config_1.DEBUG_ENABLED)
                    this.log.debug(`Created macro: ${macroId}`);
            }
            // Create commands
            const commands = device.genericMacros ?? [];
            for (const command of commands) {
                const commandId = `${devId}.${config_1.COMMANDS}.${command.name.replace(/\s+/g, '_')}`;
                await this.setObjectNotExistsAsync(commandId, {
                    type: "state",
                    common: {
                        name: command.label || command.name,
                        type: "boolean",
                        role: "button",
                        read: false,
                        write: true
                    },
                    native: command
                });
                await this.setState(commandId, false, true);
                if (config_1.DEBUG_ENABLED)
                    this.log.debug(`Created command: ${commandId}`);
            }
        }
        // Create recipes
        for (const recipe of model.recipes) {
            const recId = `${config_1.ROOMS}.${recipe.roomId}.${config_1.RECIPES}.${recipe.id}`;
            await this.setObjectNotExistsAsync(recId, {
                type: "channel",
                common: { name: recipe.name },
                native: recipe
            });
            // Create object isactive
            await this.setObjectNotExistsAsync(`${recId}.${config_1.ISACTIVE}`, {
                type: "state",
                common: {
                    name: "Active Status",
                    type: "boolean",
                    role: "indicator.status",
                    read: true,
                    write: false
                },
                native: { roomKey: recipe.roomId, recipeKey: recipe.id }
            });
            // Create object execute
            await this.setObjectNotExistsAsync(`${recId}.${config_1.EXECUTE}`, {
                type: "state",
                common: {
                    name: "Execute Recipe",
                    type: "boolean",
                    role: "button",
                    read: false,
                    write: true
                },
                native: { roomKey: recipe.roomId, recipeKey: recipe.id }
            });
            if (config_1.DEBUG_ENABLED)
                this.log.debug(`Created recipe object: ${recId}`);
        }
        // Start polling
        this.startRecipePolling(model.recipes);
    }
    // Monitor state change
    async onStateChange(id, state) {
        if (!state || state.ack || state.val !== true)
            return;
        const obj = await this.getObjectAsync(id);
        const native = obj?.native || {};
        // Handle recipe execution
        if (id.endsWith(`.${config_1.EXECUTE}`) && native.roomKey && native.recipeKey) {
            await this.executeRecipe(native.roomKey, native.recipeKey);
            return;
        }
        // Handle macro trigger
        if (id.includes(`.${config_1.MACROS}.`) && native.roomKey && native.deviceKey && native.macroKey) {
            await this.triggerMacro(native.roomKey, native.deviceKey, native.macroKey);
            return;
        }
        // Handle generic command trigger
        if (id.includes(`.${config_1.COMMANDS}.`) && native.roomKey && native.deviceKey && native.macroKey) {
            await this.triggerMacro(native.roomKey, native.deviceKey, native.macroKey);
            return;
        }
        this.log.warn(`Unhandled state change: ${id}`);
    }
    // Trigger macro
    async triggerMacro(roomKey, deviceKey, macroKey) {
        const url = `http://${this.brainIp}:${this.brainPort}/${config_1.API_BASE_URL}/rooms/${roomKey}/devices/${deviceKey}/macros/${macroKey}/${config_1.TRIGGER}`;
        try {
            await axios_1.default.get(url);
            this.log.info(`Triggered macro ${macroKey} on device ${deviceKey} in room ${roomKey}`);
        }
        catch (err) {
            this.log.error(`Failed to trigger macro: ${err.message}`);
        }
    }
    // Execute recipe
    async executeRecipe(roomKey, recipeKey) {
        const url = `http://${this.brainIp}:${this.brainPort}/${config_1.API_BASE_URL}/rooms/${roomKey}/recipes/${recipeKey}/${config_1.EXECUTE}`;
        try {
            await axios_1.default.get(url);
            this.log.info(`Executed recipe ${recipeKey} in room ${roomKey}`);
        }
        catch (err) {
            this.log.error(`Failed to execute recipe: ${err.message}`);
        }
    }
    // Polling active state of recipes
    startRecipePolling(recipes) {
        const intervalSec = Math.max(5, Number(this.pollInterval) || config_1.POLL_INTERVAL);
        const intervalMs = intervalSec * 1000;
        if (this.pollHandle)
            clearInterval(this.pollHandle);
        this.pollHandle = setInterval(async () => {
            const timestamp = new Date().toISOString();
            this.log.debug(`Polling recipes at ${timestamp}`);
            const brainReachable = await this.testBrainOnline();
            if (!brainReachable)
                return;
            for (const recipe of recipes) {
                const id = `${config_1.ROOMS}.${recipe.roomId}.${config_1.RECIPES}.${recipe.id}.${config_1.ISACTIVE}`;
                const url = `http://${this.brainIp}:${this.brainPort}/${config_1.API_BASE_URL}/${config_1.ROOMS}/${recipe.roomId}/${config_1.RECIPES}/${recipe.id}/${config_1.ISACTIVE}`;
                try {
                    const res = await axios_1.default.get(url);
                    const active = res.data?.active ?? false;
                    await this.setState(id, active, true);
                    if (config_1.DEBUG_ENABLED) {
                        this.log.debug(`Polled recipe "${recipe.name}" [${recipe.id}] in room "${recipe.roomId}": active = ${active}`);
                    }
                }
                catch (err) {
                    this.log.warn(`Polling failed for recipe ${recipe.name}: ${err.message}`);
                }
            }
        }, intervalMs);
    }
    // Check if brain is online
    async testBrainOnline() {
        const config = this.config;
        const url = `http://${this.brainIp}:${this.brainPort}/${config_1.API_BASE_URL}`;
        try {
            await axios_1.default.get(url, { timeout: 5000 });
            await this.setState('info.connection', true, true);
            return true;
        }
        catch {
            await this.setState('info.connection', false, true);
            return false;
        }
    }
    // Delete all objects
    async clearAllObjects() {
        const allObjects = await this.getAdapterObjectsAsync();
        let deleted = 0;
        for (const id in allObjects) {
            await this.delObjectAsync(id, { recursive: true });
            deleted++;
        }
        if (config_1.DEBUG_ENABLED)
            this.log.debug(`Deleted ${deleted} existing objects`);
    }
    // Shutdown adapter
    onUnload(callback) {
        try {
            this.log.info("Adapter is shutting down...");
            if (this.pollHandle)
                clearInterval(this.pollHandle);
            callback();
        }
        catch {
            callback();
        }
    }
}
// @ts-ignore because ioBroker expects the adapter instance to be exported like this
if (require.main !== module) {
    module.exports = (options) => new NeeoAdapter(options);
}
else {
    new NeeoAdapter();
}
